---
title: "rim - R's interface to Maxima"
output: html_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

Development version of the CRAN package. `rim` provides an interface to the powerful and fairly complete maxima computer algebra system

This repository is a fork from the original `RMaxima` created by Kseniia Shumelchyk and Hans W. Borcher [shumelchyk/rmaxima](https://github.com/shumelchyk/rmaxima), which is currently not maintained.

# Requirements
- Maxima (>= 5.42.1), this package has been tested with 5.42.1 and 5.45.0, but may also work with older versios 

# Installation

To install the current release version from CRAN:

```{r, eval = FALSE}
install.packages("rim")
```

If you want to install the latest version the easiest way is to install the R package `drat` first and add this github account as a repo:

```{r, eval = FALSE}
install.packages("drat")
drat::addRepo("rcst")
```

Now you can easily install it the usual way:

```{r eval = FALSE}
install.packages("rim")
```

# Usage

If you want to learn how to use Maxima you can check out a number of ressources from it's [project site](https://maxima.sourceforge.io/documentation.html).

## RMarkdown

This section demonstrates the use of `rim` via it's knitr engine. Alternatively, you can run each line of the Maxima code chunks via `maxima.get()`.

This page has been generated using `rim`'s knitr engine itself. 

Note that you can set the output format to LaTeX `maxima.engine.format("latex")` to get LaTeX-style expression rendering, when using pandoc as well as MathJax is loaded or embedded. Alternatively, expression outputs can be printed in MathML directly using `maxima.engine.format("mathml")`. 

When attaching the package and Maxima is installed already, then it will be set up and started in the background automatically, when a command is send. In addition, if you have installed the R-package `knitr` (which get's installed by default with this package as well), it will register maxima as a `knitr` engine. If this worked, maxima code can be used and rendered in RMarkdown documents.

```{r}
library(rim)
maxima.engine.format("latex")
```

For example, to generate this page you can download it's source `index.Rmd` from [here](https://raw.githubusercontent.com/rcst/rim/master/docs/index.Rmd) and then use `rmarkdown::render` to generate it.

```{r, eval = FALSE}
download.file(url = "https://raw.githubusercontent.com/rcst/rim/master/docs/index.Rmd", 
	      destfile = "index.Rmd")
maxima.engine.format("latex")
rmarkdown::render("index.Rmd")
```

```{r, echo = FALSE, eval = FALSE}
old <- knitr::knit_hooks$get("source")
knitr::knit_hooks$set(source = function(x, options){
  if (options$engine == "maxima") {
    if(!is.null(options$explicit)) {
      if(options$explicit) {
	opts <- gsub(",\\s*verbatim\\s*=\\s*TRUE\\s*", "", options$params.src)
	opts <- gsub(",?\\s*engine\\s*=\"maxima\"", "", opts)
	if(opts=="") bef = sprintf('\n\n    ```{maxima}\n', opts, "\n")
	else bef = sprintf('\n\n    ```{maxima,%s}\n', opts, "\n")
	stringr::str_c(
		       bef, 
		       knitr:::indent_block(paste(x, collapse = '\n'), "    "), 
		       "\n    ```\n"
	)
      } 
    }
  }
  else {
    stringr::str_c("\n\n```", tolower(options$engine), "\n", 
		   paste(x, collapse = '\n'), "\n```\n\n"
    )
  }
})
```

Now we can enter Maxima expression inside code chunks. Note that we need to end each line by `;` or `$` (suppressing output). For example we can type the following code chunk into our RMarkdown document file:


````

```{maxima}`r ''`
L: sqrt(1 - 1/R^2);
assume(R > 0)$
'integrate(x, x, 0, L) = integrate(x, x, 0, L);
```

````

In the above code chunk we define a variable `L` (that depends on another variable `R`). We tell Maximas data base to assume `R` being larger than zero and suppress any output resulting from this command. The last line prints an unevaluated integral on the left-hand side of the equal sign and on the right-hand side evaluates that same definit integral. The tick quotation mark tells Maxima not to evaluate the suceeding expression. This, when rendered into a document will be printed as 

```{maxima}
L: sqrt(1 - 1/R^2);
assume(R > 0)$
'integrate(x, x, 0, L) = integrate(x, x, 0, L);
```

The resulting output (if not suppressed) is printed after each line of code, and thus apprears as several. Input and output reference labels that are assign by Maxima are printed into he code chunk. Those can be used to refer to previous commands in other code chunks. For example

```{maxima}
sqrt(rhs(%o3));
```

takes the right-hand side of the result of the equation from input label `%i3`, which is assigned to output label `%o3` and computes the square-root of it.

Of course exercising on such simple computations is of little benefit. The real benefit comes from more complicated expression and the effort that we would need to put if we wanted to typeset the result, such as this

```{maxima}
integrate(1 / (1 + x^4), x);
```

`pandoc` automatically renders the LaTeX output format from Maxima by including MathJax JavaScript script. In general, `pandoc` takes care of how mathematical equations delimited by `$$` are rendered.

However, we can also change Maxima's output format to MathML, which works if the output document is a HTML document. 

```{r}
maxima.engine.format("mathml")
```

```{maxima}
sqrt(3/4);
```

```{maxima}
f(x) := e^(x^2)$
diff(f(x), x);
```

```{maxima}
%;
```

Notice, that we can use the symbol `%` to refer to the last expression and that this works across code chunks.

You can also replay other previous expressions by referring to their output labels. Output labels are printed in the default maxima output format `"linear"`. 

```{maxima}
log(%o1);
```

# Demos

## Distributions

This is basically a reproduced demo for `Sympy` from [Bryan Zhang's Blog](https://brianzhang01.github.io/2018/04/distributions-with-sympy/).

First we define some helper functions:

```{maxima}
area(dist) := integrate(dist, x, minf, inf)$
mean(dist) := area(dist*x)$
EX2(dist) := area(dist*x^2)$
variance(dist) := EX2(dist) - mean(dist)^2$
mgf(dist) := area(dist*%e^(x*t))$
```

### Normal Distribution

```{maxima}
normal(x) := 
      (2*%pi*sigma^2)^(-1/2) * 
      exp(-(x-mu)^2/(2*sigma^2));

assume(sigma > 0)$

area(normal(x));
mean(normal(x));
variance(normal(x));
mgf(normal(x));
```

### Laplace Distribution

```{maxima}
laplace(x) := (2*b)^-1 * exp(-abs(x - mu)/b);

load("abs_integrate")$

assume(b > 0)$

area(laplace(x));
mean(laplace(x));
variance(laplace(x));
```

### Exponential Distribution

```{maxima}
expo(x) := unit_step(x) * lambda * exp(-lambda * x);

assume(lambda > 0)$

area(expo(x));
mean(expo(x));
variance(expo(x));
```

## Matrices

```{maxima}
m: matrix([0, 1, a], [1, 0, 1], [1, 1, 0]);
transpose(m);
determinant(m);
f: invert(m), detout;
m . f;
expand(%);
factor(%);
```

## If-then-else

```{maxima}
x: 1234;
y: 2345;
```

```{maxima}
if x > y
  then x
  else y;
```
